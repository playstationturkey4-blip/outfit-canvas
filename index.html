/* ===========================
   ML ВЫРЕЗКА ФОНА (ADD-ONLY)
   =========================== */

(function(){

  if (typeof SelfieSegmentation === "undefined") return;

  const selfieSegmentation = new SelfieSegmentation({
    locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
    }
  });

  selfieSegmentation.setOptions({ modelSelection: 1 });
  selfieSegmentation.onResults(onMLResults);

  const originalFileHandler = fileInput.onchange;

  fileInput.onchange = (e) => {

    for (let file of e.target.files) {

      const img = new Image();
      img.src = URL.createObjectURL(file);

      img.onload = () => {
        selfieSegmentation.send({ image: img });
      };
    }

  };

  function onMLResults(results){

    const tempCanvas = document.createElement("canvas");
    const ctx = tempCanvas.getContext("2d");

    tempCanvas.width = results.image.width;
    tempCanvas.height = results.image.height;

    ctx.drawImage(results.image, 0, 0);

    const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

    const maskCanvas = document.createElement("canvas");
    const maskCtx = maskCanvas.getContext("2d");

    maskCanvas.width = tempCanvas.width;
    maskCanvas.height = tempCanvas.height;

    maskCtx.drawImage(results.segmentationMask, 0, 0, tempCanvas.width, tempCanvas.height);

    const maskData = maskCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

    for (let i = 0; i < imageData.data.length; i += 4) {
      const alpha = maskData.data[i];
      if (alpha < 128) {
        imageData.data[i + 3] = 0;
      }
    }

    ctx.putImageData(imageData, 0, 0);

    const finalImage = tempCanvas.toDataURL("image/png");

    if (typeof createElement === "function") {
      createElement(finalImage);
    }

  }

})();
